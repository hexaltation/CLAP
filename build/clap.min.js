"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 *
 * @description Class which when instanciated create the ColorLevelAdjusterProject controller
 *  
 * @class Clap
 */
var Clap =
/*#__PURE__*/
function () {
  function Clap(container) {
    var _this = this;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "id";
    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Clap);

    this.width = 120;
    this.height = 120;
    this.background = "#AAAAAA";
    this.margin = 10;
    this.min = 0;
    this.max = 255;
    this.lineWidth = 2;
    this.handlerSize = 10;
    this.boundary = false;
    this.boundaryColor = "#FFFFFF";
    this.gradient = false;
    this.customisable = [{
      "key": "width",
      "type": "int"
    }, {
      "key": "height",
      "type": "int"
    }, {
      "key": "background",
      "type": "hexString"
    }, {
      "key": "margin",
      "type": "int"
    }, {
      "key": "min",
      "type": "int"
    }, {
      "key": "max",
      "type": "int"
    }, {
      "key": "linewidth",
      "type": "int"
    }, {
      "key": "handlerSize",
      "type": "int"
    }, {
      "key": "boundary",
      "type": "boolean"
    }, {
      "key": "boundaryColor",
      "type": "hexString"
    }, {
      "key": "gradient",
      "type": "boolean"
    }];

    if (settings != {}) {
      this.initSettings(settings);
    }

    if (this.min >= this.max) {
      throw new Error("min must be strictly inferior to max");
    }

    this.colorLevels = {
      "red": {
        "in": {
          "min": this.min,
          "max": this.max
        },
        "out": {
          "min": this.min,
          "max": this.max
        },
        "color_value": "#FF0000",
        "displayed": true,
        "active": false,
        "label": "red",
        "mode": "screen"
      },
      "green": {
        "in": {
          "min": this.min,
          "max": this.max
        },
        "out": {
          "min": this.min,
          "max": this.max
        },
        "color_value": "#00FF00",
        "displayed": true,
        "active": false,
        "label": "green",
        "mode": "screen"
      },
      "blue": {
        "in": {
          "min": this.min,
          "max": this.max
        },
        "out": {
          "min": this.min,
          "max": this.max
        },
        "color_value": "#0000FF",
        "displayed": true,
        "active": false,
        "label": "blue",
        "mode": "screen"
      },
      "alpha": {
        "in": {
          "min": this.min,
          "max": this.max
        },
        "out": {
          "min": this.min,
          "max": this.max
        },
        "color_value": "#FFFFFF",
        "displayed": true,
        "active": false,
        "label": "alpha",
        "mode": "multiply"
      }
    };

    if (!(container instanceof Element)) {
      throw new Error("First Parameter in Clap instanciation must be instance of Element");
    }

    this.container = container;
    this.slider = document.createElement("canvas");
    this.slider.id = "color_level_" + id;
    this.container.appendChild(this.slider);
    this.event = new Event('clap_change', {
      bubbles: true
    });
    this.event.colorLevels = this.colorLevels;
    this.draw(this.slider);
    this.slider.origin = this.slider.getBoundingClientRect();
    this.selector = document.createElement("div");
    this.container.appendChild(this.selector);
    this.showHideBoxes(this.selector);
    this.clicked = false;
    this.selectedVertice = null;

    this.slider.onmousedown = function (evt) {
      _this.clicked = true;

      _this.isVerticeSelected(evt);
    };

    this.slider.onmouseup = function () {
      _this.clicked = false;
      _this.selectedVertice = null;
    };

    this.slider.onmousemove = function (evt) {
      if (_this.clicked && _this.active_layer != null && _this.selectedVertice != null) {
        var value = Math.floor((evt.pageX - _this.slider.origin.x - _this.margin) * Math.abs(_this.max - _this.min) / (_this.width - 2 * _this.margin) + _this.min);

        if (_this.selectedVertice.key === "min" && value >= _this.selectedVertice.obj["max"]) {
          _this.selectedVertice.obj[_this.selectedVertice.key] = _this.selectedVertice.obj["max"] - 1;
        } else if (_this.selectedVertice.key === "max" && value <= _this.selectedVertice.obj["min"]) {
          _this.selectedVertice.obj[_this.selectedVertice.key] = _this.selectedVertice.obj["min"] + 1;
        } else if (value < _this.min) {
          _this.selectedVertice.obj[_this.selectedVertice.key] = _this.min;
        } else if (value > _this.max) {
          _this.selectedVertice.obj[_this.selectedVertice.key] = _this.max;
        } else {
          _this.selectedVertice.obj[_this.selectedVertice.key] = value;
        }

        _this.draw(_this.slider);
      }
    };
  }

  _createClass(Clap, [{
    key: "initSettings",
    value: function initSettings(settings) {
      var _this2 = this;

      if (_typeof(settings) != 'object') {
        throw new Error('settings must be an object');
      }

      this.customisable.forEach(function (setting) {
        if (settings.hasOwnProperty(setting.key)) {
          _this2.typeChecking(settings[setting.key], setting);

          _this2[setting.key] = settings[setting.key];
        }
      });
    }
  }, {
    key: "typeChecking",
    value: function typeChecking(value, setting) {
      if (_typeof(value) !== setting.type && setting.type !== "hexString" && setting.type !== "int") {
        throw new TypeError(setting.key + " must be of type " + setting.type + ". Here it's " + "'" + _typeof(value) + "'.");
      }

      if (typeof value === 'number' && setting.type === 'int') {
        if (!Number.isInteger(value)) {
          throw new TypeError(setting.key + " must be of type " + setting.type + ". Here it's a vulgar 'number'.");
        }
      }

      if (typeof value === 'string' && setting.type === 'hexString') {
        if (!/^#[0-9A-F]{6}$/i.test(value)) {
          throw new TypeError(setting.key + " must be of type " + setting.type + ". Here it's a vulgar 'string'.");
        }
      }
    }
  }, {
    key: "draw",
    value: function draw(elem) {
      var ctx = elem.getContext('2d');

      try {
        ctx.canvas.width = this.width;
        ctx.canvas.height = this.height;
        this.draw_levels(ctx);

        if (this.gradient) {
          ctx.globalCompositeOperation = 'multiply';
          this.draw_gradient(ctx);
        }

        ctx.globalCompositeOperation = 'destination-over';

        if (this.boundary) {
          ctx.strokeStyle = this.boundaryColor;
          ctx.strokeRect(this.margin, this.margin, this.width - 2 * this.margin, this.height - 2 * this.margin);
        }

        ctx.fillStyle = this.background;
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        elem.dispatchEvent(this.event);
      } catch (e) {
        console.log(e);
      }
    }
  }, {
    key: "draw_levels",
    value: function draw_levels(ctx) {
      for (var color in this.colorLevels) {
        if (!this.colorLevels[color].displayed) {
          continue;
        }

        ctx.globalCompositeOperation = this.colorLevels[color].mode;
        this.draw_level(ctx, this.colorLevels[color]);
      }
    }
  }, {
    key: "draw_level",
    value: function draw_level(ctx, color) {
      ctx.fillStyle = color.color_value;
      var points = [color.in.min, color.in.max, color.out.max, color.out.min];
      var vertices = this.draw_from_points(ctx, points);
      this.draw_vertices(ctx, color.color_value, vertices);
    }
  }, {
    key: "draw_from_points",
    value: function draw_from_points(ctx, points) {
      ctx.beginPath();
      var vertices = {
        "nw": [(points[0] - this.min) * (this.width - 2 * this.margin) / Math.abs(this.max - this.min) + this.margin, 0 + this.margin],
        "ne": [(points[1] - this.min) * (this.width - 2 * this.margin) / Math.abs(this.max - this.min) + this.margin, 0 + this.margin],
        "se": [(points[2] - this.min) * (this.width - 2 * this.margin) / Math.abs(this.max - this.min) + this.margin, this.height - this.margin],
        "sw": [(points[3] - this.min) * (this.width - 2 * this.margin) / Math.abs(this.max - this.min) + this.margin, this.height - this.margin]
      };
      ctx.moveTo(vertices.nw[0], vertices.nw[1]);
      ctx.lineTo(vertices.ne[0], vertices.ne[1]);
      ctx.lineTo(vertices.se[0], vertices.se[1]);
      ctx.lineTo(vertices.sw[0], vertices.sw[1]);
      ctx.closePath();
      ctx.fill();
      return vertices;
    }
  }, {
    key: "draw_vertices",
    value: function draw_vertices(ctx, color, vertices) {
      for (var vertex in vertices) {
        this.draw_vertex(ctx, color, vertices[vertex]);
      }
    }
  }, {
    key: "draw_vertex",
    value: function draw_vertex(ctx, color, vertex) {
      ctx.lineWidth = this.lineWidth;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(vertex[0] - this.handlerSize / 2, vertex[1] - this.handlerSize / 2);
      ctx.lineTo(vertex[0] + this.handlerSize / 2, vertex[1] - this.handlerSize / 2);
      ctx.lineTo(vertex[0] + this.handlerSize / 2, vertex[1] + this.handlerSize / 2);
      ctx.lineTo(vertex[0] - this.handlerSize / 2, vertex[1] + this.handlerSize / 2);
      ctx.closePath();
      ctx.stroke();
    }
  }, {
    key: "draw_gradient",
    value: function draw_gradient(ctx) {
      var grd = ctx.createLinearGradient(0, 0, this.width, 0);
      grd.addColorStop(0, "black");
      grd.addColorStop(1, "white");
      ctx.fillStyle = grd;
      var points = this.get_externals_vertices();
      console.log(points);
      this.draw_from_points(ctx, points);
    }
  }, {
    key: "get_externals_vertices",
    value: function get_externals_vertices() {
      var inmin;
      var inmax;
      var outmin;
      var outmax;

      for (var color in this.colorLevels) {
        if (this.colorLevels[color].in.min < inmin || inmin === undefined) {
          inmin = this.colorLevels[color].in.min;
        }

        if (this.colorLevels[color].in.max > inmax || inmax === undefined) {
          inmax = this.colorLevels[color].in.max;
        }

        if (this.colorLevels[color].out.min < outmin || outmin === undefined) {
          outmin = this.colorLevels[color].out.min;
        }

        if (this.colorLevels[color].out.max > outmax || outmax === undefined) {
          outmax = this.colorLevels[color].out.max;
        }
      }

      return [inmin, inmax, outmax, outmin];
    }
  }, {
    key: "showHideBoxes",
    value: function showHideBoxes(selector) {
      var _this3 = this;

      selector.innerHTML = "";

      var _loop = function _loop(color) {
        var box = document.createElement("input");
        var label = document.createElement("label");
        box.type = "checkbox";
        box.value = _this3.colorLevels[color].label;
        box.id = "cb-" + _this3.colorLevels[color].label;

        if (_this3.colorLevels[color].displayed) {
          box.checked = true;
        }

        box.addEventListener('change', function (evt) {
          var current_color = evt.target.value;

          if (evt.target.checked) {
            _this3.colorLevels[current_color].displayed = true;
          } else {
            _this3.colorLevels[current_color].displayed = false;
          }

          _this3.draw(_this3.slider);
        });
        label.for = box.id;
        label.innerHTML = _this3.colorLevels[color].label;

        if (_this3.colorLevels[color].active) {
          label.style.textDecoration = "underline";
        }

        label.ondblclick = function (e) {
          _this3.selectActive(_this3.colorLevels[color]);
        };

        selector.appendChild(box);
        selector.appendChild(label);
      };

      for (var color in this.colorLevels) {
        _loop(color);
      }

      this.container.dispatchEvent(this.event);
    }
  }, {
    key: "selectActive",
    value: function selectActive(active_color) {
      for (var color in this.colorLevels) {
        if (this.colorLevels[color] === active_color && this.colorLevels[color].active == false) {
          this.colorLevels[color].active = true;
          this.active_layer = this.colorLevels[color];
        } else if (this.colorLevels[color] === active_color && this.colorLevels[color].active == true) {
          this.colorLevels[color].active = false;
          this.active_layer = null;
        } else {
          this.colorLevels[color].active = false;
        }
      }

      this.showHideBoxes(this.selector);
    }
  }, {
    key: "isVerticeSelected",
    value: function isVerticeSelected(evt) {
      if (this.active_layer != null) {
        var vertices = [{
          "obj": this.active_layer.in,
          "key": "min"
        }, {
          "obj": this.active_layer.in,
          "key": "max"
        }, {
          "obj": this.active_layer.out,
          "key": "min"
        }, {
          "obj": this.active_layer.out,
          "key": "max"
        }];
        var position = [[(this.active_layer.in.min - this.min) * (this.width - 2 * this.margin) / Math.abs(this.max - this.min) + this.margin + this.slider.origin.x, 0 + this.margin + this.slider.origin.y], [(this.active_layer.in.max - this.min) * (this.width - 2 * this.margin) / Math.abs(this.max - this.min) + this.margin + this.slider.origin.x, 0 + this.margin + this.slider.origin.y], [(this.active_layer.out.min - this.min) * (this.width - 2 * this.margin) / Math.abs(this.max - this.min) + this.margin + this.slider.origin.x, this.height - this.margin + this.slider.origin.y], [(this.active_layer.out.max - this.min) * (this.width - 2 * this.margin) / Math.abs(this.max - this.min) + this.margin + this.slider.origin.x, this.height - this.margin + this.slider.origin.y]];

        for (var i = 0; i < position.length; i++) {
          if (position[i][0] - this.handlerSize / 2 < evt.pageX && evt.pageX < position[i][0] + this.handlerSize / 2 && position[i][1] - this.handlerSize / 2 < evt.pageY && evt.pageY < position[i][1] + this.handlerSize / 2) {
            this.selectedVertice = vertices[i];
            break;
          }
        }
      }
    }
  }]);

  return Clap;
}();
